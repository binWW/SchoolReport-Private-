# 第一章
    多维度的显微镜图像是当前生物学研究领域不可或缺的重要数据来源。

     往往不足以观察复杂的3D结构和发现3D或更高维度图像中的多个对象（例如，细胞）之间的关系。 因此，需要有效的工具来准确地探索3D和多维的图像数据以及基于这些图像数据得到的相应的“重建”对象。
# 第二章 背景介绍

## Vaa3D平台

    - 3D可视化分析工具(3D Visualization-assisted analysis),英文简称为Vaa3D,中文简称为挖三维，是一个跨平台的开源的软件平台。该软件平台的主要目标是提供一个简洁的跨平台的图形界面平台，可以用于大规模多维度的图像数据的可视化和定量分析，以方便和促进生物学和医学研究。Vaa3D 具有以下几个显著特征，包括（i）多维度图像数据的可视化，（ii）3D图像对象的构件和定量测量，（iii）多个3D图像的比较，融合和管理，（iv）异构图像和其相应的表面结构的可视化，以及（v）使用其插件界面扩展更多的Vaa3D功能。Vaa3D平台基于三种自动化流水线将多种实现图像可视化以及定量分析的复杂应用集成到自身平台中，这三种自动流水线分别是（i）各种图像数据的聚类、分割和3D表面重建的自动化流水线，（ii）3D图像拼接融合的自动化流水线，（iii）用于神经元细胞形态重建、量化和比较分析的自动化流水线。
 


# 第三章 Vaa3D平台中虚拟现实显示与交互的引入
## 系统设计
    - 系统设计目标
        原始的Vaa3D平台中，虽然已经可以显示并处理3D医学图像，但始终是在2D屏幕上操作3D的模型/图像，难以直观地从各个角度观察3D图像，使用鼠标对图像进行平移旋转缩放等操作十分的笨拙，更难以对图像的某个位置进行精确的定位与进一步的标记操作。 因此我们预想为Vaa3D 平台引入新型的显示方式，即将这些3D医学图像显示在虚拟现实环境中，可以更为直观地观察到整个3D图像的立体结构，即便没有实现任何的图像平移旋转操作，也可以通过在虚拟现实环境中的任意走动与VR头盔角度的任意变换，十分方便的就能观察到3D图像各个角度各个维度的图像特征。 更何况我们还可以在虚拟现实环境中直接对3D图像进行各种直观操作，例如通过手柄对3D图像进行平移旋转缩放等操作，结合用户走动与VR头盔的旋转，极大地方便了用户对3D图像的各个维度各个角度的观察，提升了用户的使用体验，进一步提升用户的工作效率。另一方面，我们预想为Vaa3D平台在虚拟现实环境中引入新型的交互方式，使得之前在2D屏幕上通过鼠标键盘能够实现的操作，例如 trace one single neuron，define a marker, edit one single neuron等 都能够在虚拟现实环境中实现，甚至某些操作在引入虚拟现实环境中后能得到优化，进一步提升用户的工作效率。
    - 系统设计架构
        画一个系统架构图
    - 系统需求分析图****
    - 使用界面设计
    - 手柄UI设计

## 系统实现  

### 显示

 - Vaa3d 中的数据结构
    - 参考 彭老师 论文 翻译过来
    - 3D image
        Vaa3D平台支持读取多种格式的图像源文件，并且支持2D、3D，4D以及5D图像源数据的读取和可视化。在本虚拟现实系统中，所需要显示的大多数为三维图像，常用的三维图像源文件格式包括：Tiff stack (.tif, .tiff)；Zeiss LSM (.lsm);MRC (used for electron microscopy images) (.mrc);以及Vaa3D平台中输出的图像源文件格式(.v3draw, .raw, *.v3dpbd, *.vaa3dpbd)等。以上这些格式的三维图像均能够在本虚拟现实系统中正常高效地显示。
    - SWC 
        神经元形态重建的流程中，以图象为输入，最终得到一个树状结构的数据，这种数据结构一般被存储在SWC格式文件(.swc)中。SWC文件是一种通用的神经元重建结果的存储格式。从数学角度来看，SWC文件中的数据结构可以描述为节点的集合。此集合中，不允许存在环路，至多存在一条从一个节点到另一个节点的路径（不重复）。SWC文件中的实际数据结构如**表格和图**所示。
``` 表格
    ##n,type,x,y,z,radius,parent
    1 274 286.439 68.8652 448.123 3 -1
    2 274 284.487 68.4821 444.265 3 1
    3 274 280.128 63.78 437.698 2 2
    4 274 274.095 61.308 430.314 1 3
    5 274 266.755 64.6307 427.101 2 4
```
        在**表**中，每一行表示SWC文件中的一个节点，节点的集合构成了一颗完整的节点树。第一列"n"表示此节点的序号(以1为起始点，但不一定表示头节点。)，SWC文件中的每个结点的序号都是唯一的不重复的，保证此节点的集合中不会存在环路。第二列"type"表示节点的类型。不同类型的节点拥有不同的意义，例如节点类型为1(node.type = 1)表示此节点属于神经元轴突部分，节点类型为2(node.type = 2)表示节点属于神经元树突部分。不同类型的节点在Vaa3D平台可视化时以不同颜色来显示以进行区分。第三至五列"x,y,z"表示此节点在空间中的3D位置，一般以保留两位小数 的浮点数表示。第六列"radius"表示节点的大小，形式上表现为显示整条节点树的3D Surface模式时此节点的半径。第七列"parent"表示此节点的父结点的序号(n),每个节点只允许存在一个父结点，但允许存在多个子节点。
    - marker
        marker是Vaa3D平台一种用于标记的数据结构。此数据结构可以用来标记三维图像中的一些关键信息，比如神经元分叉点，神经元末梢等，也可以用于辅助一些自动示踪(Auto-trcing)算法的结果计算，例如标记自动算法的起始位置、收敛位置以及聚类中心等等。marker的实际数据结构如**表格和图**所示。
``` 表格
##x,y,z,radius,shape,name,comment, color_r,color_g,color_b
147.448, 122.709, 73.639, 0, 1, unknown, , 174,116,144
```
        在**表**中，第一至三列"x,y,z"表示marker在空间中的3D位置，第四列"radius"表示此marker的半径大小，第五列"shape"表示此marker的形状，第六列"name"表示此marker的名字,第七列"comment"表示针对此marker的注释信息，第八至十列"color_r,color_g,color_b"表示此marker的颜色信息，即R、G、B通道的值，与SWC中的type属性相同，在某些应用中，不同颜色的marker表示不同的意义。
 - image in VR 显示
    - opengl 显示
    - OpenGL 作为一个十分强大的3D图形开发工具，它本身不属于一种编程语言，它是图像硬件的软件接口，介于计算机图形与计算机硬件之间。OpenGL本身包含七百多个函数[]，本质上属于3D空间的图形和模型库。开发人员可以利用OpenGL构建3D模型和图像，并定义特定的交互操作。OpenGL具有十足的可移植性，它不依赖于操作系统和硬件环境，并且运行效率高，功能丰富。
        - OpenGL的主要功能：
            - 模型绘制
            - 基本坐标变换
            - 光照处理
            - 物体着色
            - 纹理映射
            - 动画效果
            - 位图和图像处理
            - 反走样
    - 在OpenGL中，点是最基本的图形单元，即定点(Vertex).所有的复杂图形都可以由一组定点的集合描述，顶点间如何连接决定了绘制的图形的类型。一般情况下，OpenGL中一个定点被画成单个像素(pixel)点.两个顶点的组合构成线段，OpenGl中的线段与数学定义中的线段不同，是有宽度的。多个线段首尾相连形成的笔和区域就构成了一个多边形，多边形一般由其各个端点来描述。 点、线段和多边形构成可OpenGL中的基本几何图元。
 - SWC 显示
    - 在本虚拟现实系统中，SWC会存在两种不同的显示方式：skeleton模式和surface模式。
    - skeleton模式：使用固定宽度的线段将节点与节点之间连接起来，所有数据中的节点全部连接后最终形成一条连续的曲线**图**。此模式下，我们能够更直观地看到整个NeuronTree/节点树的拓扑结构，能够更清晰地看到整个神经元结构的分支数和走向，更能轻易分辨出整个节点树中的关键节点。 
        -  跟据SWC的数据结构，我们用OpenGL中的单个顶点表示SWC中的每个node，用顶点的坐标表示node在三维空间中的位置，用顶点之间连接而成的线段表示node之间的父子关系，用线段的颜色表示node的type。
        实现步骤：
        1. 生成并绑定SWC某个segment的VAO&VBO；
        ``` C++
        //setup vao and vbo stuff
        glGenVertexArrays(1, &LineModeVAO);
        glGenBuffers(1, &LineModeVBO);
        glGenBuffers(1, &LineModeIndex);

        //now allocate buffers
        glBindVertexArray(LineModeVAO);

        glBindBuffer(GL_ARRAY_BUFFER, LineModeVBO);
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, LineModeIndex);

        glEnableVertexAttribArray(0);
        glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 2*sizeof(glm::vec3), (GLvoid*)0);
        uintptr_t offset =  sizeof( glm::vec3 );
        glEnableVertexAttribArray( 1 );
        glVertexAttribPointer( 1, 3, GL_FLOAT, GL_FALSE, 2*sizeof(glm::vec3), (const void *)offset);

        glBindVertexArray(0);
        ```
        2. 将SWC中的节点的空间坐标XYZ，父子关系和颜色信息type转换成OpenGl的顶点位置信息，绘制顺序和颜色信息，并拷贝到对应的VAO&VBO中；
``` C++
    vector <glm::vec3> vertices;
    vector<GLuint> indices;    
    NeuronSWC node = neuron_Tree.listNeuron.at(i);
    vertices.push_back(glm::vec3(node.x,node.y,node.z));//顶点位置信息
    vertices.push_back(glm::vec3(node.r,node.g,node.b));//顶点颜色信息
    indices.push_back(node);
    indices.push_back(node.parent);//绘制顺序数组

    glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(glm::vec3), &vertices[0],(drawMode==0)?GL_STATIC_DRAW:GL_DYNAMIC_DRAW);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() * sizeof(GLuint), &indices[0],(drawMode==0)?GL_STATIC_DRAW: GL_DYNAMIC_DRAW);//将数据拷贝至对应的VAO&VBO中
```
        3. 在GPU中渲染对应的VAO&VBO;
``` C++
        //draw sketch lines
        glUseProgram(m_unControllerTransformProgramID);
        glUniformMatrix4fv(m_nControllerMatrixLocation, 1, GL_FALSE, model_M.get());
        glBindVertexArray(LineModeVAO);
        glDrawElements(GL_LINES, m_uiSketchMorphologyLineModeVertcount, GL_UNSIGNED_INT, 0);
```
    - surface模式： 此模式着重点在于显示神经元重建结构的3D表面信息，能够更加清晰直观地看到3D重建结果与实际三维图像数据的拟合程度。将node显示成sphere 将node之间的线段显示成cylinder 针对单个节点，我们会在对应的位置渲染一个颜色半径与该节点的数据结构相同的球体作为该节点的3D结构；针对节点之间的连接，我们会根据节点构成的线段的两个端点的半径大小和位置渲染出一个对应半径的圆台来表示。**图**
    实现步骤与关键代码：
    1.准备节点和其父结点的球的VAO&VBO
``` C++
    NeuronSWC node = neuron_Tree.listNeuron.at(i);
    //draw sphere
    spheres.push_back(new Sphere((float)(node.r)));//球的VAO&VBO
    spheresPos.push_back(glm::vec3(node.x,node.y,node.z));//空间坐标信息  
    
    // draw parent sphere
    NeuronSWC parent = node.parent;
    spheres.push_back(new Sphere((float)(parent.r)));//球的VAO&VBO
    spheresPos.push_back(glm::vec3(parent.x,parent.y,parent.z));//空间坐标信息  
```
    2.准备两个节点之间的圆台的 VAO&VBO
``` C++
    NeuronSWC node = neuron_Tree.listNeuron.at(i);
    NeuronSWC parent = node.parent;
    float dist = glm::sqrt((node.x-parent.x)*(node.x-parent.x)+(node.y-parent.y)*(node.y-parent.y)+(node.z-parent.z)*(node.z-parent.z));
    cylinders.push_back(new Cylinder(parent.r,node.r,dist));  
```
    3.在GPU中渲染对应的VAO&VBO;
``` C++
    Sphere* sphere = spheres.at(i);
    morphologyShader->setMat4("model", model);
    morphologyShader->setVec3("objectColor", sphere.color);
    glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
    sphere->Render();

    Cylinder* cylinder = cylinders.at(i);
    morphologyShader->setMat4("model", model);
    morphologyShader->setVec3("objectColor", cylinders.color);
    glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
    cylinder->Render();
```    

 - marker 显示: 在本虚拟现实系统中，marker的显示方式与Vaa3D平台普通的显示方式相似，都是讲marker作为一个球体显示在对应的空间位置中。
 - volume rendering 显示 in VR
        根据摄像机位置发出的射线计算出新的立方体cube，将3Dimage显示在cube中，即可实现人可以走进图像中的效果。**图**
 - 图像变换
    - 根据图像size选定一个center position 和 global scale， 再结合当前VR环境的大小和位置，计算得到一个全局变换矩阵，global matrix，将整个3D Image图像显示在虚拟现实环境中心的位置，并缩放至一个合适的大小。

### 交互
 - 右手柄的平移旋转缩放操作
    按下右手柄的触摸板，显示如图的UI贴图时，表示此时已经进入平移模式。接着触摸touchpad的上下左右方向即可让整体图象沿着右手柄射线方向为基准的上下左右方向移动，抬起手指即可停止平移。 **公式 矩阵平移**  
    再次按下右手柄的触摸板，显示如图的UI贴图时，表示此时已经进入旋转模式。接着触摸touchpad的上下左右方向即可让整体图象沿着对应方向旋转，抬起手指即可停止旋转。 **公式 矩阵旋转**  
    再次按下右手柄的触摸板，显示如图的UI贴图时，表示此时已经进入缩放模式。接着触摸touchpad的上方向即可让整体图象放大；触摸touchpad的下方向即可让整体图象缩小，抬起手指即可停止缩放。 **公式 矩阵缩放**    
    再次按下右手柄触摸板，显示如图的UI贴图时，表示当前为非功能模式，即使触摸到touchpad也不会产生任何影响。
 - 左手柄的快捷平移旋转操作
    同时，我们为VR添加了另一种更加快捷的平移旋转方式，只需要持续按住左手柄的扳机(trigger)，整个图像/空间就会随着左手柄的旋转和平移来进行对应的变换操作，接着再松开左手柄扳机即可固定住当前的角度和位置。**公式 矩阵变换**
 - 图像对比度/亮度调整
    在一般情况下，即不调整任何显示参数的情况下，图像中的某些信号较低的区域在VR场景中是不可见或者不太清晰的，（同样，在于Vaa3D的2D 屏幕上也是不可见的）**对比图如图** 多数情况下，这些亮度/信号强度较为微弱的信号/区域我们可以认定为噪声信号，但同时这些信息在很多时候对于我们来说是有用的，因此我们需要实现在VR中也可以清晰看到这些微弱信号的方法。通过调整图像显示的对比度和亮度可以将这些微弱信号清晰地显示出来。
    按下左手柄的grip button，也就是我们的Switch Control 按钮，直到显示如图的UI贴图时，表示此时进入了对比度调整模式。按下贴图中对应的+/-键即可控制图像对比度的增减。对比度的范围控制在[0,50]的范围内。  
    按下左手柄的grip button，也就是我们的Switch Control 按钮，直到显示如图的UI贴图时，表示此时进入了亮度调整模式。按下贴图中对应的+/-键即可控制图像亮度的增减。亮度的范围控制在[0,100]的范围内。
 - neuron tracing in VR
    - [设计理念]首先我们需要实现的操作是，在虚拟现实环境中可以对图像信号进行手工描绘，也就是专业术语中的neuron tracing。作为生物学家可能最经常使用的功能，我们需要尽可能的方便/简化用户的操作，因此我们将右手柄的默认模式设置为画线模式/trace模式，只需要按下扳机即可进行操作。
    - [实现方法] 按下右手柄的grip button，也就是我们的Switch Control按钮，直到显示如图的UI贴图时，表示此时进入了画线模式。此模式下，持续按下右手柄的扳机键，即可在手柄中心位置，即位置**N**的球处，根据手柄移动的轨迹，持续生成连续曲线。当用户在虚拟现实环境下进行neuron tracing的工作时，只需要按下扳机并沿着需要trace的位置移动手柄，即可完成对图像信号的描绘。
    - 在实际的tracing工作中，必定会产生各种各样的误差操作或者错误操作，因此我们需要实现纠错的功能。我们为此系统设计了两种不同的纠错功能：1. 删除模式。 此模式下，只需要在想要删除的segment附近按下扳机，即可将此segment删除，此模式适用于整条segment误差过大或者未知错误的情况；2.移动模式。 此模式适用于整条segment中只有单个或者少量node误差过大的情况，此模式下在想要纠错/移动的node附近按下扳机即可对此node进行拖拽，松开扳机即可将此node固定在当前手柄位置处。
    - 按下右手柄的grip button，也就是我们的Switch Control按钮，直到显示如图的UI贴图时，表示此时进入了删除模式。此模式下只需要在想要删除的segment附近按下扳机，即可将此segment删除。 再次按下右手柄的grip button，也就是我们的Switch Control按钮，直到显示如图的UI贴图时，表示此时进入了移动模式。此模式下在想要纠错/移动的node附近按下扳机即可对此node进行拖拽，松开扳机即可将此node固定在当前手柄位置处。
    - 实际的tracing工作中，专家们经常会需要用到marker来对关键node或者关键位置进行标记，而且有些autotracing 重建算法也依赖于专家们标记的marker来产生更为精确的重建结果。因此，我们需要在虚拟现实环境下同样实现marker的增删操作。marker的增删功能的设计理念与线大致相似，在新增marker模式下，按下右手柄扳机即可在当前手柄位置生成一个球作为marker显示在对应位置；在删除marker模式下，在想要删除的marker的附近按下右手柄扳机即可删除对应marker。
    - 按下右手柄的grip button，也就是我们的Switch Control按钮，直到显示如图的UI贴图时，表示此时进入了新增marker模式。此模式下按下右手柄扳机即可在当前手柄位置生成一个球作为marker显示在对应位置。 再次按下右手柄的grip button，也就是我们的Switch Control按钮，直到显示如图的UI贴图时，表示此时进入了删除marker模式。此模式下在想要删除的marker的附近按下右手柄扳机即可删除对应marker。
    - [颜色调整]SWC中，每个node均有一个共同的属性，就是type。不同的type表示SWC中的node代表不同的意义，在Vaa3D中以不同颜色来进行区分，例如：type = 0，颜色为 white[0xffffff]表示该node属于。。。 type = 1，颜色为 black[0x000000]表示该node属于。。。。**列个表格？** 另一方面，每一个marker也都拥有一个color属性，意义大致等同于node的type。因此在虚拟现实环境下我们也需要能画出不同颜色不同type的segment和marker。按下左手柄的grip button，也就是我们的Switch Control 按钮，直到显示如图的UI贴图时，表示此时进入了颜色切换模式。我们选取了7种最常用的有明确意义的颜色做为虚拟现实环境下的注释annotation的颜色，按下touchpad即可在这7种颜色重进行循环切换，同时右手柄中心位置出现实的球的颜色也同步会切换为当前选定的注释颜色，此后无论是画线的颜色还是标记marker的颜色都会以当前选定的颜色显示，但之前已经画的线和标记的marker的颜色不会改变。
    - [保存]在使用过程中，随时按下右手柄上方的save button 如图，即可将当前的工作保存下来，所有的segment都会被合并为一条完整的neuron tree保存在当前exe目录下，命名格式为`******`+当前时间.swc，所有的marker都会被保存在当前恶心恶目录下，命名格式为`********`+当前时间.marker。当当前工作进行到一定阶段，可以随时保存，当下一阶段工作开始后重新载入上次工作保存下来的文件，继续展开后续的工作。
    - [撤销重做]**撤销重做操作的重要性介绍**